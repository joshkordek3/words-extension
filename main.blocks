<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="i??yh9)rh=[B;5-Pm@5f" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="9)Uihae()9.VRHcs63BK" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace hello {" line1="   let temp_txt = &quot;&quot;" line2="//%block" line3="//% group=&quot;Converting&quot;" line4="export function extract_numbers_from (text: string) {" line5="    temp_txt = &quot;&quot;" line6="    for (let index2 = 0; index2 &lt;= text.length - 1; index2++) {" line7="        if (!(alphabet().includes(text.charAt(index2)))) {" line8="            temp_txt = &quot;&quot; + temp_txt + text.charAt(index2)" line9="        }" line10="    }" line11="    return parseFloat(temp_txt)" line12="}" line13="//%block" line14="//% group=&quot;Location&quot;" line15="export function location_in_the_alphabet (letter: string) {" line16="    if (letter.length == 1) {" line17="        return index(alphabet(), letter) + 1" line18="    }" line19="    return 0" line20="}" line21="//%block" line22="//% group=&quot;Alphabet&quot;" line23="export function alphabet () {" line24="    return &quot;abcdefghijklmnopqrstuvwxyz&quot;" line25="}" line26="//%block" line27="//% group=&quot;Reading&quot;" line28="export function substring (text: string, num: number, length: number) {" line29="    temp_txt = &quot;&quot;" line30="    for (let index22 = 0; index22 &lt;= length - 1; index22++) {" line31="        temp_txt = &quot;&quot; + temp_txt + text.charAt(index22 + num)" line32="    }" line33="    return temp_txt" line34="}" line35="//%block" line36="//% group=&quot;Reading&quot;" line37="export function read_from_to_letters (text: string, _: string) {" line38="    if (_.length == 3) {" line39="        return read_from_letter(text, &quot;&quot; + convertToText(index(text, read_untilfrom(&quot;until&quot;, _, &quot;-&quot;)) + 1) + &quot;-&quot; + (index(text, read_untilfrom(&quot;from&quot;, _, &quot;-&quot;)) + 1))" line40="    } else {" line41="        return &quot;&quot;" line42="    }" line43="}" line44="//%block" line45="//% group=&quot;Location&quot;" line46="export function index (text: string, _this: string) {" line47="    for (let index23 = 0; index23 &lt;= text.length - 1; index23++) {" line48="        if (text.charAt(index23) == _this) {" line49="            return index23" line50="        }" line51="    }" line52="    return -1" line53="}" line54="//%block" line55="//% group=&quot;Reading&quot;" line56="export function read_untilfrom (untilfrom: string, text: string, text2: string) {" line57="    if (untilfrom == &quot;from&quot;) {" line58="        return read_from(text, text2)" line59="    } else if (untilfrom == &quot;until&quot;) {" line60="        return read_until(text, text2)" line61="    }" line62="    return &quot;&quot;" line63="}" line64="function read_until (read: string, find: string) {" line65="    if (find.length == 1) {" line66="        return substring(read, 0, index(read, find))" line67="    } else {" line68="        return &quot;&quot;" line69="    }" line70="}" line71="//%block" line72="//% group=&quot;Reading&quot;" line73="export function read_from_letter (text: string, num: string) {" line74="    return substring(text, parseFloat(read_until(num, &quot;-&quot;)) - 1, parseFloat(read_from(num, &quot;-&quot;)) - parseFloat(read_until(num, &quot;-&quot;)) + 1)" line75="}" line76="function read_from (text: string, _from: string) {" line77="    if (_from.length == 1) {" line78="        return substring(text, index(text, _from) + 1, text.length - index(text, _from))" line79="    } else {" line80="        return &quot;&quot;" line81="    }" line82="}" line83="}" numlines="84"></mutation></block></statement></block></xml>